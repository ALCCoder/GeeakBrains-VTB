# ООП в Java

## Инкапсуляция, Наследование и Полиморфизм

#### Инкапсуляция - механизм языка позволяющий связать данные и методы в один объект.

#### Наследование - процесс в результате которого один объект приобретает свйоства друого. 

#### Полиморфизм - это свойство посредсвом которого мы можем иметь один интерфейс, но множество реализаций

**Конструктор**

Конструктор это самый обычный метод который вызывается при создании объекта. И служит для инициализации этих объектов.

**Модификаторы доступа**

Их существует 4 типа:

    private, default, protected, public
Каждый следующий уровень доступа расширяет предыдущий.

*private* - доступ только из этого класса

*default* - доступ  из этого класса + доступ из любого класса в рамках пакета в котором лежит класс.

*protected* - внутри пакета от private, внутри пакета от default + любой наследник этого класса где бы он не находился.

*public* - доступ везде


Если никакой модификатор доступа мы не поставили у поля, то это пакетный доступ или доступ по умолчанию - 
это модификатор доступа *default*

Нам нужно ставить модификатор доступа *private* у полей класса. *private* Означает что доступ к полю доступен только из этого класса.
Мы стараемся максимально урезать доступ к полям.


**Ключевое слово static**

Статическое поле является общим для всех объектов данного класса.
(Вся статика инциализируется когда класс загружается в память. Класс загружается в память когда мы впервые к нему 
обращаемся.)

* Обращаться к статическому полю лучше всего через класс а не через объект. MyClass.field а не new MyClass().field

* У нас может быть статический метод.

* А так же может быть статический блок инициализации.

* **Мы не можем в статическом методе обращаться к полям класса!!!** Почему? Да потому что поля класса не понятно какому объекту
будут принадлежать. А вдруг никакого объекта вообще не создано и мы попытаемся вызвать статический метод 
который будет обращаться к полю класса, а ни одного объекта этого класса не создано. Для обращений к обычным полям класса нужен объект
а для статик полей и методов никакого объекта класса не нужно.
И вообще статика лежит в другой области памяти.  (И еще нужно понимать в Java некоторые ограничения искуственные
или нет. Ну, то есть заложены именно разработчиками)

Так же есть статический блок инциализации, допустим как это например происходит в jdbc драйверах в момент подгрузки jdbc
драйвера он закидывает себе в driver manager и тем самым мы можем его использовать.

```java
static {
    String field1 = "1";
    String field2 = "1";
}
```

**Геттеры и сеттеры зачем?** Если можем напрямую через поле!? 

Допустим в сеттер мы можем добавлять какую то логику. Например для проверки длины строки или что то другое.
То есть мы можем докручивать какую то логику при создании или наполнения полей объекта. 
Это повышает безопасность и расширяет наши возможности.

Ну допустим мы хотим чтобы какое то поля было только для чтения. Ставим private и делаем геттер. 

Ключевое слово
`this` это ссылка на объект у которого мы вызываем данный метод и как правило когда мы прописываем сеттеры и конструкторы и у нас
там есть аргументы. И Java всегда старается получить ссылку на какую то перменную всегда на ту котрая ближе к себе.

```java
    public Cat(String name, String color, int age) {
        this.name = name;
        this.color = color;
        this.age = age;
    }
```

В данном случае если мы не будем писать `this.name = name` а напишем `name = name` то мы аргументу name присвоим значение его само себе.


В данном коде будет ошибка на этапе компиляции _**java: variable c might not have been initialized**_
```java
 public static void main(String[] args) {
        int c;
        System.out.println(c);
    }
```

А если создать объект через конструктор и не задать ни одно поле объекта то поля **String** по умолчанию инциализируются null
**int** 0, **boolean** false.

**Наследование**

* Не стоит объявлять и в родителе и в наследнике одинаковые поля если в этом нет смысла.
* **package**  нужны во первых чтобы использовать protected а так же если к проекту две библиотеки подключены
в котрых два одинаковых класса то вы указаваете путь до покета и имя одинакового класса: com.geek.Animal Animal, com.beek.Animal Animal

* Есть конструкторы по умолчанию. Даже если мы не создали сами конструктор за нас его создаст Java. Конструкторов может быть сколько угодно.
* Наследник в своем конструкторе обязан вызывать коснтруктор родителя. Даже если явно нет то всегда за нас виртуально Java вызывает //super();
* Каждый НЕ абстрактный класс который наследуюется от абстрактного обязан реализовать переопределение методов через @Override абстрактного класса. Почему?
А потому что вдруг ты создал объект класса и хочешь вызвать его метод но при этом этот метод нереализован!? Будет ошибка.


**Equals**
Когда реализуем переопределение метода equal 

* Те поля которые используем в equals используем и в hashCode чтобы не было такого что equals вернул true а hashCode-ы 
у объектов одинаковые.

# Вопросы

1) Зачем делать приватный конструктор у класса? 
2) Почему летит stackOverflow если создать объект этого же класса внутри конструктора жтого класса



![Текст описания](https://www.example.com/image.jpg)


<http://example.com/>

<address@example.com>

[Перейти к Заголовку 1](#title1)

## <a id="title1">Заголовок 1</a>
Какой-то контент

- [x] Задача 1
- [ ] Задача 2
- [ ] Задача 3

| Заголовок 1 | Заголовок 2 |
| ----------- | ----------- |
| Ячейка 1    | Ячейка 2   |
| Ячейка 3    | Ячейка 4   |


:smile:
:laughing:
:blush:

```python
print("Привет, мир!")
```

# Заголовок первого уровня
## Заголовок второго уровня
### Заголовок третьего уровня
#### Заголовок четвёртого уровня
##### Заголовок пятого уровня
###### Заголовок шестого уровня